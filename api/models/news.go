// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// News is an object representing the database table.
type News struct {
	ID              int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	NewsType        string      `boil:"news_type" json:"news_type" toml:"news_type" yaml:"news_type"`
	Title           string      `boil:"title" json:"title" toml:"title" yaml:"title"`
	SubTitle        null.String `boil:"sub_title" json:"sub_title,omitempty" toml:"sub_title" yaml:"sub_title,omitempty"`
	Content         null.String `boil:"content" json:"content,omitempty" toml:"content" yaml:"content,omitempty"`
	PlainText       null.String `boil:"plain_text" json:"plain_text,omitempty" toml:"plain_text" yaml:"plain_text,omitempty"`
	AuthorID        null.Int    `boil:"author_id" json:"author_id,omitempty" toml:"author_id" yaml:"author_id,omitempty"`
	TranslatorID    null.Int    `boil:"translator_id" json:"translator_id,omitempty" toml:"translator_id" yaml:"translator_id,omitempty"`
	PublisherID     null.Int    `boil:"publisher_id" json:"publisher_id,omitempty" toml:"publisher_id" yaml:"publisher_id,omitempty"`
	Thumbnail       null.String `boil:"thumbnail" json:"thumbnail,omitempty" toml:"thumbnail" yaml:"thumbnail,omitempty"`
	UserID          null.Int    `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	AddTime         time.Time   `boil:"add_time" json:"add_time" toml:"add_time" yaml:"add_time"`
	Enabled         int8        `boil:"enabled" json:"enabled" toml:"enabled" yaml:"enabled"`
	Link            null.String `boil:"link" json:"link,omitempty" toml:"link" yaml:"link,omitempty"`
	ReadingDuration null.Int    `boil:"reading_duration" json:"reading_duration,omitempty" toml:"reading_duration" yaml:"reading_duration,omitempty"`
	Status          bool        `boil:"status" json:"status" toml:"status" yaml:"status"`
	FromTime        null.Time   `boil:"from_time" json:"from_time,omitempty" toml:"from_time" yaml:"from_time,omitempty"`
	ToTime          null.Time   `boil:"to_time" json:"to_time,omitempty" toml:"to_time" yaml:"to_time,omitempty"`

	R *newsR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L newsL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var NewsColumns = struct {
	ID              string
	NewsType        string
	Title           string
	SubTitle        string
	Content         string
	PlainText       string
	AuthorID        string
	TranslatorID    string
	PublisherID     string
	Thumbnail       string
	UserID          string
	AddTime         string
	Enabled         string
	Link            string
	ReadingDuration string
	Status          string
	FromTime        string
	ToTime          string
}{
	ID:              "id",
	NewsType:        "news_type",
	Title:           "title",
	SubTitle:        "sub_title",
	Content:         "content",
	PlainText:       "plain_text",
	AuthorID:        "author_id",
	TranslatorID:    "translator_id",
	PublisherID:     "publisher_id",
	Thumbnail:       "thumbnail",
	UserID:          "user_id",
	AddTime:         "add_time",
	Enabled:         "enabled",
	Link:            "link",
	ReadingDuration: "reading_duration",
	Status:          "status",
	FromTime:        "from_time",
	ToTime:          "to_time",
}

// Generated where

var NewsWhere = struct {
	ID              whereHelperint
	NewsType        whereHelperstring
	Title           whereHelperstring
	SubTitle        whereHelpernull_String
	Content         whereHelpernull_String
	PlainText       whereHelpernull_String
	AuthorID        whereHelpernull_Int
	TranslatorID    whereHelpernull_Int
	PublisherID     whereHelpernull_Int
	Thumbnail       whereHelpernull_String
	UserID          whereHelpernull_Int
	AddTime         whereHelpertime_Time
	Enabled         whereHelperint8
	Link            whereHelpernull_String
	ReadingDuration whereHelpernull_Int
	Status          whereHelperbool
	FromTime        whereHelpernull_Time
	ToTime          whereHelpernull_Time
}{
	ID:              whereHelperint{field: "`news`.`id`"},
	NewsType:        whereHelperstring{field: "`news`.`news_type`"},
	Title:           whereHelperstring{field: "`news`.`title`"},
	SubTitle:        whereHelpernull_String{field: "`news`.`sub_title`"},
	Content:         whereHelpernull_String{field: "`news`.`content`"},
	PlainText:       whereHelpernull_String{field: "`news`.`plain_text`"},
	AuthorID:        whereHelpernull_Int{field: "`news`.`author_id`"},
	TranslatorID:    whereHelpernull_Int{field: "`news`.`translator_id`"},
	PublisherID:     whereHelpernull_Int{field: "`news`.`publisher_id`"},
	Thumbnail:       whereHelpernull_String{field: "`news`.`thumbnail`"},
	UserID:          whereHelpernull_Int{field: "`news`.`user_id`"},
	AddTime:         whereHelpertime_Time{field: "`news`.`add_time`"},
	Enabled:         whereHelperint8{field: "`news`.`enabled`"},
	Link:            whereHelpernull_String{field: "`news`.`link`"},
	ReadingDuration: whereHelpernull_Int{field: "`news`.`reading_duration`"},
	Status:          whereHelperbool{field: "`news`.`status`"},
	FromTime:        whereHelpernull_Time{field: "`news`.`from_time`"},
	ToTime:          whereHelpernull_Time{field: "`news`.`to_time`"},
}

// NewsRels is where relationship names are stored.
var NewsRels = struct {
	Author     string
	Translator string
	Publisher  string
}{
	Author:     "Author",
	Translator: "Translator",
	Publisher:  "Publisher",
}

// newsR is where relationships are stored.
type newsR struct {
	Author     *Author
	Translator *Author
	Publisher  *Publisher
}

// NewStruct creates a new relationship struct
func (*newsR) NewStruct() *newsR {
	return &newsR{}
}

// newsL is where Load methods for each relationship are stored.
type newsL struct{}

var (
	newsAllColumns            = []string{"id", "news_type", "title", "sub_title", "content", "plain_text", "author_id", "translator_id", "publisher_id", "thumbnail", "user_id", "add_time", "enabled", "link", "reading_duration", "status", "from_time", "to_time"}
	newsColumnsWithoutDefault = []string{"title", "sub_title", "content", "plain_text", "author_id", "translator_id", "publisher_id", "thumbnail", "user_id", "link", "reading_duration", "from_time", "to_time"}
	newsColumnsWithDefault    = []string{"id", "news_type", "add_time", "enabled", "status"}
	newsPrimaryKeyColumns     = []string{"id"}
)

type (
	// NewsSlice is an alias for a slice of pointers to News.
	// This should generally be used opposed to []News.
	NewsSlice []*News
	// NewsHook is the signature for custom News hook methods
	NewsHook func(context.Context, boil.ContextExecutor, *News) error

	newsQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	newsType                 = reflect.TypeOf(&News{})
	newsMapping              = queries.MakeStructMapping(newsType)
	newsPrimaryKeyMapping, _ = queries.BindMapping(newsType, newsMapping, newsPrimaryKeyColumns)
	newsInsertCacheMut       sync.RWMutex
	newsInsertCache          = make(map[string]insertCache)
	newsUpdateCacheMut       sync.RWMutex
	newsUpdateCache          = make(map[string]updateCache)
	newsUpsertCacheMut       sync.RWMutex
	newsUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var newsBeforeInsertHooks []NewsHook
var newsBeforeUpdateHooks []NewsHook
var newsBeforeDeleteHooks []NewsHook
var newsBeforeUpsertHooks []NewsHook

var newsAfterInsertHooks []NewsHook
var newsAfterSelectHooks []NewsHook
var newsAfterUpdateHooks []NewsHook
var newsAfterDeleteHooks []NewsHook
var newsAfterUpsertHooks []NewsHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *News) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range newsBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *News) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range newsBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *News) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range newsBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *News) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range newsBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *News) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range newsAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *News) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range newsAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *News) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range newsAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *News) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range newsAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *News) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range newsAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddNewsHook registers your hook function for all future operations.
func AddNewsHook(hookPoint boil.HookPoint, newsHook NewsHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		newsBeforeInsertHooks = append(newsBeforeInsertHooks, newsHook)
	case boil.BeforeUpdateHook:
		newsBeforeUpdateHooks = append(newsBeforeUpdateHooks, newsHook)
	case boil.BeforeDeleteHook:
		newsBeforeDeleteHooks = append(newsBeforeDeleteHooks, newsHook)
	case boil.BeforeUpsertHook:
		newsBeforeUpsertHooks = append(newsBeforeUpsertHooks, newsHook)
	case boil.AfterInsertHook:
		newsAfterInsertHooks = append(newsAfterInsertHooks, newsHook)
	case boil.AfterSelectHook:
		newsAfterSelectHooks = append(newsAfterSelectHooks, newsHook)
	case boil.AfterUpdateHook:
		newsAfterUpdateHooks = append(newsAfterUpdateHooks, newsHook)
	case boil.AfterDeleteHook:
		newsAfterDeleteHooks = append(newsAfterDeleteHooks, newsHook)
	case boil.AfterUpsertHook:
		newsAfterUpsertHooks = append(newsAfterUpsertHooks, newsHook)
	}
}

// OneG returns a single news record from the query using the global executor.
func (q newsQuery) OneG(ctx context.Context) (*News, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single news record from the query.
func (q newsQuery) One(ctx context.Context, exec boil.ContextExecutor) (*News, error) {
	o := &News{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for news")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all News records from the query using the global executor.
func (q newsQuery) AllG(ctx context.Context) (NewsSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all News records from the query.
func (q newsQuery) All(ctx context.Context, exec boil.ContextExecutor) (NewsSlice, error) {
	var o []*News

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to News slice")
	}

	if len(newsAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all News records in the query, and panics on error.
func (q newsQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all News records in the query.
func (q newsQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count news rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table, and panics on error.
func (q newsQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q newsQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if news exists")
	}

	return count > 0, nil
}

// Author pointed to by the foreign key.
func (o *News) Author(mods ...qm.QueryMod) authorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.AuthorID),
	}

	queryMods = append(queryMods, mods...)

	query := Authors(queryMods...)
	queries.SetFrom(query.Query, "`author`")

	return query
}

// Translator pointed to by the foreign key.
func (o *News) Translator(mods ...qm.QueryMod) authorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.TranslatorID),
	}

	queryMods = append(queryMods, mods...)

	query := Authors(queryMods...)
	queries.SetFrom(query.Query, "`author`")

	return query
}

// Publisher pointed to by the foreign key.
func (o *News) Publisher(mods ...qm.QueryMod) publisherQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.PublisherID),
	}

	queryMods = append(queryMods, mods...)

	query := Publishers(queryMods...)
	queries.SetFrom(query.Query, "`publisher`")

	return query
}

// LoadAuthor allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (newsL) LoadAuthor(ctx context.Context, e boil.ContextExecutor, singular bool, maybeNews interface{}, mods queries.Applicator) error {
	var slice []*News
	var object *News

	if singular {
		object = maybeNews.(*News)
	} else {
		slice = *maybeNews.(*[]*News)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &newsR{}
		}
		if !queries.IsNil(object.AuthorID) {
			args = append(args, object.AuthorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &newsR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AuthorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AuthorID) {
				args = append(args, obj.AuthorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`author`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Author")
	}

	var resultSlice []*Author
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Author")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for author")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for author")
	}

	if len(newsAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Author = foreign
		if foreign.R == nil {
			foreign.R = &authorR{}
		}
		foreign.R.News = append(foreign.R.News, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AuthorID, foreign.ID) {
				local.R.Author = foreign
				if foreign.R == nil {
					foreign.R = &authorR{}
				}
				foreign.R.News = append(foreign.R.News, local)
				break
			}
		}
	}

	return nil
}

// LoadTranslator allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (newsL) LoadTranslator(ctx context.Context, e boil.ContextExecutor, singular bool, maybeNews interface{}, mods queries.Applicator) error {
	var slice []*News
	var object *News

	if singular {
		object = maybeNews.(*News)
	} else {
		slice = *maybeNews.(*[]*News)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &newsR{}
		}
		if !queries.IsNil(object.TranslatorID) {
			args = append(args, object.TranslatorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &newsR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.TranslatorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.TranslatorID) {
				args = append(args, obj.TranslatorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`author`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Author")
	}

	var resultSlice []*Author
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Author")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for author")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for author")
	}

	if len(newsAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Translator = foreign
		if foreign.R == nil {
			foreign.R = &authorR{}
		}
		foreign.R.TranslatorNews = append(foreign.R.TranslatorNews, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TranslatorID, foreign.ID) {
				local.R.Translator = foreign
				if foreign.R == nil {
					foreign.R = &authorR{}
				}
				foreign.R.TranslatorNews = append(foreign.R.TranslatorNews, local)
				break
			}
		}
	}

	return nil
}

// LoadPublisher allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (newsL) LoadPublisher(ctx context.Context, e boil.ContextExecutor, singular bool, maybeNews interface{}, mods queries.Applicator) error {
	var slice []*News
	var object *News

	if singular {
		object = maybeNews.(*News)
	} else {
		slice = *maybeNews.(*[]*News)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &newsR{}
		}
		if !queries.IsNil(object.PublisherID) {
			args = append(args, object.PublisherID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &newsR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PublisherID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PublisherID) {
				args = append(args, obj.PublisherID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`publisher`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Publisher")
	}

	var resultSlice []*Publisher
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Publisher")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for publisher")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for publisher")
	}

	if len(newsAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Publisher = foreign
		if foreign.R == nil {
			foreign.R = &publisherR{}
		}
		foreign.R.News = append(foreign.R.News, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PublisherID, foreign.ID) {
				local.R.Publisher = foreign
				if foreign.R == nil {
					foreign.R = &publisherR{}
				}
				foreign.R.News = append(foreign.R.News, local)
				break
			}
		}
	}

	return nil
}

// SetAuthorG of the news to the related item.
// Sets o.R.Author to related.
// Adds o to related.R.News.
// Uses the global database handle.
func (o *News) SetAuthorG(ctx context.Context, insert bool, related *Author) error {
	return o.SetAuthor(ctx, boil.GetContextDB(), insert, related)
}

// SetAuthor of the news to the related item.
// Sets o.R.Author to related.
// Adds o to related.R.News.
func (o *News) SetAuthor(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Author) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `news` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"author_id"}),
		strmangle.WhereClause("`", "`", 0, newsPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AuthorID, related.ID)
	if o.R == nil {
		o.R = &newsR{
			Author: related,
		}
	} else {
		o.R.Author = related
	}

	if related.R == nil {
		related.R = &authorR{
			News: NewsSlice{o},
		}
	} else {
		related.R.News = append(related.R.News, o)
	}

	return nil
}

// RemoveAuthorG relationship.
// Sets o.R.Author to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *News) RemoveAuthorG(ctx context.Context, related *Author) error {
	return o.RemoveAuthor(ctx, boil.GetContextDB(), related)
}

// RemoveAuthor relationship.
// Sets o.R.Author to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *News) RemoveAuthor(ctx context.Context, exec boil.ContextExecutor, related *Author) error {
	var err error

	queries.SetScanner(&o.AuthorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("author_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Author = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.News {
		if queries.Equal(o.AuthorID, ri.AuthorID) {
			continue
		}

		ln := len(related.R.News)
		if ln > 1 && i < ln-1 {
			related.R.News[i] = related.R.News[ln-1]
		}
		related.R.News = related.R.News[:ln-1]
		break
	}
	return nil
}

// SetTranslatorG of the news to the related item.
// Sets o.R.Translator to related.
// Adds o to related.R.TranslatorNews.
// Uses the global database handle.
func (o *News) SetTranslatorG(ctx context.Context, insert bool, related *Author) error {
	return o.SetTranslator(ctx, boil.GetContextDB(), insert, related)
}

// SetTranslator of the news to the related item.
// Sets o.R.Translator to related.
// Adds o to related.R.TranslatorNews.
func (o *News) SetTranslator(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Author) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `news` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"translator_id"}),
		strmangle.WhereClause("`", "`", 0, newsPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.TranslatorID, related.ID)
	if o.R == nil {
		o.R = &newsR{
			Translator: related,
		}
	} else {
		o.R.Translator = related
	}

	if related.R == nil {
		related.R = &authorR{
			TranslatorNews: NewsSlice{o},
		}
	} else {
		related.R.TranslatorNews = append(related.R.TranslatorNews, o)
	}

	return nil
}

// RemoveTranslatorG relationship.
// Sets o.R.Translator to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *News) RemoveTranslatorG(ctx context.Context, related *Author) error {
	return o.RemoveTranslator(ctx, boil.GetContextDB(), related)
}

// RemoveTranslator relationship.
// Sets o.R.Translator to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *News) RemoveTranslator(ctx context.Context, exec boil.ContextExecutor, related *Author) error {
	var err error

	queries.SetScanner(&o.TranslatorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("translator_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Translator = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.TranslatorNews {
		if queries.Equal(o.TranslatorID, ri.TranslatorID) {
			continue
		}

		ln := len(related.R.TranslatorNews)
		if ln > 1 && i < ln-1 {
			related.R.TranslatorNews[i] = related.R.TranslatorNews[ln-1]
		}
		related.R.TranslatorNews = related.R.TranslatorNews[:ln-1]
		break
	}
	return nil
}

// SetPublisherG of the news to the related item.
// Sets o.R.Publisher to related.
// Adds o to related.R.News.
// Uses the global database handle.
func (o *News) SetPublisherG(ctx context.Context, insert bool, related *Publisher) error {
	return o.SetPublisher(ctx, boil.GetContextDB(), insert, related)
}

// SetPublisher of the news to the related item.
// Sets o.R.Publisher to related.
// Adds o to related.R.News.
func (o *News) SetPublisher(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Publisher) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `news` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"publisher_id"}),
		strmangle.WhereClause("`", "`", 0, newsPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PublisherID, related.ID)
	if o.R == nil {
		o.R = &newsR{
			Publisher: related,
		}
	} else {
		o.R.Publisher = related
	}

	if related.R == nil {
		related.R = &publisherR{
			News: NewsSlice{o},
		}
	} else {
		related.R.News = append(related.R.News, o)
	}

	return nil
}

// RemovePublisherG relationship.
// Sets o.R.Publisher to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *News) RemovePublisherG(ctx context.Context, related *Publisher) error {
	return o.RemovePublisher(ctx, boil.GetContextDB(), related)
}

// RemovePublisher relationship.
// Sets o.R.Publisher to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *News) RemovePublisher(ctx context.Context, exec boil.ContextExecutor, related *Publisher) error {
	var err error

	queries.SetScanner(&o.PublisherID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("publisher_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Publisher = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.News {
		if queries.Equal(o.PublisherID, ri.PublisherID) {
			continue
		}

		ln := len(related.R.News)
		if ln > 1 && i < ln-1 {
			related.R.News[i] = related.R.News[ln-1]
		}
		related.R.News = related.R.News[:ln-1]
		break
	}
	return nil
}

// AllNews retrieves all the records using an executor.
func AllNews(mods ...qm.QueryMod) newsQuery {
	mods = append(mods, qm.From("`news`"))
	return newsQuery{NewQuery(mods...)}
}

// FindNewsG retrieves a single record by ID.
func FindNewsG(ctx context.Context, iD int, selectCols ...string) (*News, error) {
	return FindNews(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindNews retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindNews(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*News, error) {
	newsObj := &News{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `news` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, newsObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from news")
	}

	return newsObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *News) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *News) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no news provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(newsColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	newsInsertCacheMut.RLock()
	cache, cached := newsInsertCache[key]
	newsInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			newsAllColumns,
			newsColumnsWithDefault,
			newsColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(newsType, newsMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(newsType, newsMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `news` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `news` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `news` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, newsPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into news")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == newsMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for news")
	}

CacheNoHooks:
	if !cached {
		newsInsertCacheMut.Lock()
		newsInsertCache[key] = cache
		newsInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single News record using the global executor.
// See Update for more documentation.
func (o *News) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the News.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *News) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	newsUpdateCacheMut.RLock()
	cache, cached := newsUpdateCache[key]
	newsUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			newsAllColumns,
			newsPrimaryKeyColumns,
		)

		if len(wl) == 0 {
			return 0, errors.New("models: unable to update news, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `news` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, newsPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(newsType, newsMapping, append(wl, newsPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update news row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for news")
	}

	if !cached {
		newsUpdateCacheMut.Lock()
		newsUpdateCache[key] = cache
		newsUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q newsQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q newsQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for news")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for news")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o NewsSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o NewsSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), newsPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `news` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, newsPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in news slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all news")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *News) UpsertG(ctx context.Context, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateColumns, insertColumns)
}

var mySQLNewsUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *News) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no news provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(newsColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLNewsUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	newsUpsertCacheMut.RLock()
	cache, cached := newsUpsertCache[key]
	newsUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			newsAllColumns,
			newsColumnsWithDefault,
			newsColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			newsAllColumns,
			newsPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert news, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "news", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `news` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(newsType, newsMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(newsType, newsMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for news")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == newsMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(newsType, newsMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for news")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for news")
	}

CacheNoHooks:
	if !cached {
		newsUpsertCacheMut.Lock()
		newsUpsertCache[key] = cache
		newsUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single News record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *News) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single News record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *News) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no News provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), newsPrimaryKeyMapping)
	sql := "DELETE FROM `news` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from news")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for news")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q newsQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no newsQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from news")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for news")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o NewsSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o NewsSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(newsBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), newsPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `news` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, newsPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from news slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for news")
	}

	if len(newsAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *News) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: no News provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *News) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindNews(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *NewsSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: empty NewsSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *NewsSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := NewsSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), newsPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `news`.* FROM `news` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, newsPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in NewsSlice")
	}

	*o = slice

	return nil
}

// NewsExistsG checks if the News row exists.
func NewsExistsG(ctx context.Context, iD int) (bool, error) {
	return NewsExists(ctx, boil.GetContextDB(), iD)
}

// NewsExists checks if the News row exists.
func NewsExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `news` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if news exists")
	}

	return exists, nil
}
