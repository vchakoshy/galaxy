// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// Book is an object representing the database table.
type Book struct {
	ID                                    int           `boil:"id" json:"id" toml:"id" yaml:"id"`
	Title                                 string        `boil:"title" json:"title" toml:"title" yaml:"title"`
	SubTitle                              null.String   `boil:"sub_title" json:"sub_title,omitempty" toml:"sub_title" yaml:"sub_title,omitempty"`
	Slug                                  null.String   `boil:"slug" json:"slug,omitempty" toml:"slug" yaml:"slug,omitempty"`
	Format                                string        `boil:"format" json:"format" toml:"format" yaml:"format"`
	ContentType                           string        `boil:"content_type" json:"content_type" toml:"content_type" yaml:"content_type"`
	Password                              null.String   `boil:"password" json:"password,omitempty" toml:"password" yaml:"password,omitempty"`
	Password2                             null.String   `boil:"password2" json:"password2,omitempty" toml:"password2" yaml:"password2,omitempty"`
	PublisherID                           null.Int      `boil:"publisher_id" json:"publisher_id,omitempty" toml:"publisher_id" yaml:"publisher_id,omitempty"`
	PublishDate                           null.Time     `boil:"publish_date" json:"publish_date,omitempty" toml:"publish_date" yaml:"publish_date,omitempty"`
	Language                              string        `boil:"language" json:"language" toml:"language" yaml:"language"`
	AuthorID                              null.Int      `boil:"author_id" json:"author_id,omitempty" toml:"author_id" yaml:"author_id,omitempty"`
	Author2ID                             null.Int      `boil:"author2_id" json:"author2_id,omitempty" toml:"author2_id" yaml:"author2_id,omitempty"`
	Author3ID                             null.Int      `boil:"author3_id" json:"author3_id,omitempty" toml:"author3_id" yaml:"author3_id,omitempty"`
	TranslatorID                          null.Int      `boil:"translator_id" json:"translator_id,omitempty" toml:"translator_id" yaml:"translator_id,omitempty"`
	Translator2ID                         null.Int      `boil:"translator2_id" json:"translator2_id,omitempty" toml:"translator2_id" yaml:"translator2_id,omitempty"`
	Translator3ID                         null.Int      `boil:"translator3_id" json:"translator3_id,omitempty" toml:"translator3_id" yaml:"translator3_id,omitempty"`
	Isbn                                  null.String   `boil:"isbn" json:"isbn,omitempty" toml:"isbn" yaml:"isbn,omitempty"`
	IsbnInt                               null.String   `boil:"isbn_int" json:"isbn_int,omitempty" toml:"isbn_int" yaml:"isbn_int,omitempty"`
	Volume                                null.Int      `boil:"volume" json:"volume,omitempty" toml:"volume" yaml:"volume,omitempty"`
	PaperPrice                            null.Float32  `boil:"paper_price" json:"paper_price,omitempty" toml:"paper_price" yaml:"paper_price,omitempty"`
	ApplyPaperPrice                       int8          `boil:"apply_paper_price" json:"apply_paper_price" toml:"apply_paper_price" yaml:"apply_paper_price"`
	Price                                 int           `boil:"price" json:"price" toml:"price" yaml:"price"`
	MainPrice                             null.Int      `boil:"main_price" json:"main_price,omitempty" toml:"main_price" yaml:"main_price,omitempty"`
	MultiplePrice                         bool          `boil:"multiple_price" json:"multiple_price" toml:"multiple_price" yaml:"multiple_price"`
	PriceTMP                              null.Int      `boil:"price_tmp" json:"price_tmp,omitempty" toml:"price_tmp" yaml:"price_tmp,omitempty"`
	BasePrice                             string        `boil:"base_price" json:"base_price" toml:"base_price" yaml:"base_price"`
	Price2                                types.Decimal `boil:"price2" json:"price2" toml:"price2" yaml:"price2"`
	PackageDiscountPublisherParticipation null.Int      `boil:"package_discount_publisher_participation" json:"package_discount_publisher_participation,omitempty" toml:"package_discount_publisher_participation" yaml:"package_discount_publisher_participation,omitempty"`
	Free                                  int8          `boil:"free" json:"free" toml:"free" yaml:"free"`
	UploadTime                            time.Time     `boil:"upload_time" json:"upload_time" toml:"upload_time" yaml:"upload_time"`
	Filename                              null.String   `boil:"filename" json:"filename,omitempty" toml:"filename" yaml:"filename,omitempty"`
	SampleFilename                        null.String   `boil:"sample_filename" json:"sample_filename,omitempty" toml:"sample_filename" yaml:"sample_filename,omitempty"`
	ImageName                             null.String   `boil:"image_name" json:"image_name,omitempty" toml:"image_name" yaml:"image_name,omitempty"`
	ImageSquare                           null.String   `boil:"image_square" json:"image_square,omitempty" toml:"image_square" yaml:"image_square,omitempty"`
	OriginalTitle                         null.String   `boil:"original_title" json:"original_title,omitempty" toml:"original_title" yaml:"original_title,omitempty"`
	OriginalPublisherID                   null.Int      `boil:"original_publisher_id" json:"original_publisher_id,omitempty" toml:"original_publisher_id" yaml:"original_publisher_id,omitempty"`
	Description                           string        `boil:"description" json:"description" toml:"description" yaml:"description"`
	Publish                               int8          `boil:"publish" json:"publish" toml:"publish" yaml:"publish"`
	PublishTime                           null.Time     `boil:"publish_time" json:"publish_time,omitempty" toml:"publish_time" yaml:"publish_time,omitempty"`
	CheckTime                             null.Time     `boil:"check_time" json:"check_time,omitempty" toml:"check_time" yaml:"check_time,omitempty"`
	Bugs                                  null.String   `boil:"bugs" json:"bugs,omitempty" toml:"bugs" yaml:"bugs,omitempty"`
	CRC                                   null.Uint     `boil:"crc" json:"crc,omitempty" toml:"crc" yaml:"crc,omitempty"`
	SampleCRC                             null.Uint     `boil:"sample_crc" json:"sample_crc,omitempty" toml:"sample_crc" yaml:"sample_crc,omitempty"`
	Keywords                              null.String   `boil:"keywords" json:"keywords,omitempty" toml:"keywords" yaml:"keywords,omitempty"`
	Su                                    null.Int8     `boil:"su" json:"su,omitempty" toml:"su" yaml:"su,omitempty"`
	Sales                                 null.Int      `boil:"sales" json:"sales,omitempty" toml:"sales" yaml:"sales,omitempty"`
	SalesTime                             null.Int      `boil:"sales_time" json:"sales_time,omitempty" toml:"sales_time" yaml:"sales_time,omitempty"`
	SalesTMP                              null.Int      `boil:"sales_tmp" json:"sales_tmp,omitempty" toml:"sales_tmp" yaml:"sales_tmp,omitempty"`
	SalesTimeTMP                          null.Int      `boil:"sales_time_tmp" json:"sales_time_tmp,omitempty" toml:"sales_time_tmp" yaml:"sales_time_tmp,omitempty"`
	Rate                                  float64       `boil:"rate" json:"rate" toml:"rate" yaml:"rate"`
	RateCount                             uint          `boil:"rate_count" json:"rate_count" toml:"rate_count" yaml:"rate_count"`
	New                                   bool          `boil:"new" json:"new" toml:"new" yaml:"new"`
	Featured                              bool          `boil:"featured" json:"featured" toml:"featured" yaml:"featured"`
	LastGoodreadsCheck                    null.Time     `boil:"last_goodreads_check" json:"last_goodreads_check,omitempty" toml:"last_goodreads_check" yaml:"last_goodreads_check,omitempty"`
	Filesize                              null.Int64    `boil:"filesize" json:"filesize,omitempty" toml:"filesize" yaml:"filesize,omitempty"`
	SampleFilesize                        null.Int      `boil:"sample_filesize" json:"sample_filesize,omitempty" toml:"sample_filesize" yaml:"sample_filesize,omitempty"`
	BKCRC                                 null.Uint     `boil:"bk_crc" json:"bk_crc,omitempty" toml:"bk_crc" yaml:"bk_crc,omitempty"`
	BKSampleCRC                           null.Uint     `boil:"bk_sample_crc" json:"bk_sample_crc,omitempty" toml:"bk_sample_crc" yaml:"bk_sample_crc,omitempty"`
	PageCount                             null.Int      `boil:"page_count" json:"page_count,omitempty" toml:"page_count" yaml:"page_count,omitempty"`
	Provider                              string        `boil:"provider" json:"provider" toml:"provider" yaml:"provider"`
	NarratorID                            null.Uint     `boil:"narrator_id" json:"narrator_id,omitempty" toml:"narrator_id" yaml:"narrator_id,omitempty"`
	Narrator2ID                           null.Uint     `boil:"narrator2_id" json:"narrator2_id,omitempty" toml:"narrator2_id" yaml:"narrator2_id,omitempty"`
	Narrator3ID                           null.Uint     `boil:"narrator3_id" json:"narrator3_id,omitempty" toml:"narrator3_id" yaml:"narrator3_id,omitempty"`
	Duration                              null.Int      `boil:"duration" json:"duration,omitempty" toml:"duration" yaml:"duration,omitempty"`
	OldCRC                                null.Int      `boil:"old_crc" json:"old_crc,omitempty" toml:"old_crc" yaml:"old_crc,omitempty"`
	OldFilesize                           null.Int      `boil:"old_filesize" json:"old_filesize,omitempty" toml:"old_filesize" yaml:"old_filesize,omitempty"`
	CRCDone                               int8          `boil:"crc_done" json:"crc_done" toml:"crc_done" yaml:"crc_done"`
	SuitableFor                           string        `boil:"suitable_for" json:"suitable_for" toml:"suitable_for" yaml:"suitable_for"`
	FromAge                               null.Int8     `boil:"from_age" json:"from_age,omitempty" toml:"from_age" yaml:"from_age,omitempty"`
	ToAge                                 null.Int8     `boil:"to_age" json:"to_age,omitempty" toml:"to_age" yaml:"to_age,omitempty"`
	Flag                                  null.Int      `boil:"flag" json:"flag,omitempty" toml:"flag" yaml:"flag,omitempty"`
	Encrypted                             bool          `boil:"encrypted" json:"encrypted" toml:"encrypted" yaml:"encrypted"`
	ImageCheck                            null.Int      `boil:"image_check" json:"image_check,omitempty" toml:"image_check" yaml:"image_check,omitempty"`
	EncryptCheck                          null.Int      `boil:"encrypt_check" json:"encrypt_check,omitempty" toml:"encrypt_check" yaml:"encrypt_check,omitempty"`
	SampleCheck                           null.Int      `boil:"sample_check" json:"sample_check,omitempty" toml:"sample_check" yaml:"sample_check,omitempty"`
	SeoTitle                              null.String   `boil:"seo_title" json:"seo_title,omitempty" toml:"seo_title" yaml:"seo_title,omitempty"`
	SeoDescription                        null.String   `boil:"seo_description" json:"seo_description,omitempty" toml:"seo_description" yaml:"seo_description,omitempty"`
	TMPTitle                              null.String   `boil:"tmp_title" json:"tmp_title,omitempty" toml:"tmp_title" yaml:"tmp_title,omitempty"`
	SeoProblem                            bool          `boil:"seo_problem" json:"seo_problem" toml:"seo_problem" yaml:"seo_problem"`
	Canonical                             null.String   `boil:"canonical" json:"canonical,omitempty" toml:"canonical" yaml:"canonical,omitempty"`
	SeoFrontShow                          bool          `boil:"seo_front_show" json:"seo_front_show" toml:"seo_front_show" yaml:"seo_front_show"`
	Extradata                             null.String   `boil:"extradata" json:"extradata,omitempty" toml:"extradata" yaml:"extradata,omitempty"`
	LastUpdate                            null.Time     `boil:"last_update" json:"last_update,omitempty" toml:"last_update" yaml:"last_update,omitempty"`

	R *bookR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L bookL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var BookColumns = struct {
	ID                                    string
	Title                                 string
	SubTitle                              string
	Slug                                  string
	Format                                string
	ContentType                           string
	Password                              string
	Password2                             string
	PublisherID                           string
	PublishDate                           string
	Language                              string
	AuthorID                              string
	Author2ID                             string
	Author3ID                             string
	TranslatorID                          string
	Translator2ID                         string
	Translator3ID                         string
	Isbn                                  string
	IsbnInt                               string
	Volume                                string
	PaperPrice                            string
	ApplyPaperPrice                       string
	Price                                 string
	MainPrice                             string
	MultiplePrice                         string
	PriceTMP                              string
	BasePrice                             string
	Price2                                string
	PackageDiscountPublisherParticipation string
	Free                                  string
	UploadTime                            string
	Filename                              string
	SampleFilename                        string
	ImageName                             string
	ImageSquare                           string
	OriginalTitle                         string
	OriginalPublisherID                   string
	Description                           string
	Publish                               string
	PublishTime                           string
	CheckTime                             string
	Bugs                                  string
	CRC                                   string
	SampleCRC                             string
	Keywords                              string
	Su                                    string
	Sales                                 string
	SalesTime                             string
	SalesTMP                              string
	SalesTimeTMP                          string
	Rate                                  string
	RateCount                             string
	New                                   string
	Featured                              string
	LastGoodreadsCheck                    string
	Filesize                              string
	SampleFilesize                        string
	BKCRC                                 string
	BKSampleCRC                           string
	PageCount                             string
	Provider                              string
	NarratorID                            string
	Narrator2ID                           string
	Narrator3ID                           string
	Duration                              string
	OldCRC                                string
	OldFilesize                           string
	CRCDone                               string
	SuitableFor                           string
	FromAge                               string
	ToAge                                 string
	Flag                                  string
	Encrypted                             string
	ImageCheck                            string
	EncryptCheck                          string
	SampleCheck                           string
	SeoTitle                              string
	SeoDescription                        string
	TMPTitle                              string
	SeoProblem                            string
	Canonical                             string
	SeoFrontShow                          string
	Extradata                             string
	LastUpdate                            string
}{
	ID:                                    "id",
	Title:                                 "title",
	SubTitle:                              "sub_title",
	Slug:                                  "slug",
	Format:                                "format",
	ContentType:                           "content_type",
	Password:                              "password",
	Password2:                             "password2",
	PublisherID:                           "publisher_id",
	PublishDate:                           "publish_date",
	Language:                              "language",
	AuthorID:                              "author_id",
	Author2ID:                             "author2_id",
	Author3ID:                             "author3_id",
	TranslatorID:                          "translator_id",
	Translator2ID:                         "translator2_id",
	Translator3ID:                         "translator3_id",
	Isbn:                                  "isbn",
	IsbnInt:                               "isbn_int",
	Volume:                                "volume",
	PaperPrice:                            "paper_price",
	ApplyPaperPrice:                       "apply_paper_price",
	Price:                                 "price",
	MainPrice:                             "main_price",
	MultiplePrice:                         "multiple_price",
	PriceTMP:                              "price_tmp",
	BasePrice:                             "base_price",
	Price2:                                "price2",
	PackageDiscountPublisherParticipation: "package_discount_publisher_participation",
	Free:                                  "free",
	UploadTime:                            "upload_time",
	Filename:                              "filename",
	SampleFilename:                        "sample_filename",
	ImageName:                             "image_name",
	ImageSquare:                           "image_square",
	OriginalTitle:                         "original_title",
	OriginalPublisherID:                   "original_publisher_id",
	Description:                           "description",
	Publish:                               "publish",
	PublishTime:                           "publish_time",
	CheckTime:                             "check_time",
	Bugs:                                  "bugs",
	CRC:                                   "crc",
	SampleCRC:                             "sample_crc",
	Keywords:                              "keywords",
	Su:                                    "su",
	Sales:                                 "sales",
	SalesTime:                             "sales_time",
	SalesTMP:                              "sales_tmp",
	SalesTimeTMP:                          "sales_time_tmp",
	Rate:                                  "rate",
	RateCount:                             "rate_count",
	New:                                   "new",
	Featured:                              "featured",
	LastGoodreadsCheck:                    "last_goodreads_check",
	Filesize:                              "filesize",
	SampleFilesize:                        "sample_filesize",
	BKCRC:                                 "bk_crc",
	BKSampleCRC:                           "bk_sample_crc",
	PageCount:                             "page_count",
	Provider:                              "provider",
	NarratorID:                            "narrator_id",
	Narrator2ID:                           "narrator2_id",
	Narrator3ID:                           "narrator3_id",
	Duration:                              "duration",
	OldCRC:                                "old_crc",
	OldFilesize:                           "old_filesize",
	CRCDone:                               "crc_done",
	SuitableFor:                           "suitable_for",
	FromAge:                               "from_age",
	ToAge:                                 "to_age",
	Flag:                                  "flag",
	Encrypted:                             "encrypted",
	ImageCheck:                            "image_check",
	EncryptCheck:                          "encrypt_check",
	SampleCheck:                           "sample_check",
	SeoTitle:                              "seo_title",
	SeoDescription:                        "seo_description",
	TMPTitle:                              "tmp_title",
	SeoProblem:                            "seo_problem",
	Canonical:                             "canonical",
	SeoFrontShow:                          "seo_front_show",
	Extradata:                             "extradata",
	LastUpdate:                            "last_update",
}

// Generated where

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Float32 struct{ field string }

func (w whereHelpernull_Float32) EQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float32) NEQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float32) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float32) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Float32) LT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float32) LTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float32) GT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float32) GTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperint8 struct{ field string }

func (w whereHelperint8) EQ(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint8) NEQ(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint8) LT(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint8) LTE(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint8) GT(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint8) GTE(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpertypes_Decimal struct{ field string }

func (w whereHelpertypes_Decimal) EQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_Decimal) NEQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_Decimal) LT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Decimal) LTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Decimal) GT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Decimal) GTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Uint struct{ field string }

func (w whereHelpernull_Uint) EQ(x null.Uint) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Uint) NEQ(x null.Uint) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Uint) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Uint) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Uint) LT(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Uint) LTE(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Uint) GT(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Uint) GTE(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Int8 struct{ field string }

func (w whereHelpernull_Int8) EQ(x null.Int8) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int8) NEQ(x null.Int8) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int8) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int8) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Int8) LT(x null.Int8) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int8) LTE(x null.Int8) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int8) GT(x null.Int8) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int8) GTE(x null.Int8) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperfloat64 struct{ field string }

func (w whereHelperfloat64) EQ(x float64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperfloat64) NEQ(x float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperfloat64) LT(x float64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperfloat64) LTE(x float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperfloat64) GT(x float64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperfloat64) GTE(x float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperuint struct{ field string }

func (w whereHelperuint) EQ(x uint) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperuint) NEQ(x uint) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperuint) LT(x uint) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperuint) LTE(x uint) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperuint) GT(x uint) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperuint) GTE(x uint) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpernull_Int64 struct{ field string }

func (w whereHelpernull_Int64) EQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int64) NEQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Int64) LT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int64) LTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int64) GT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int64) GTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var BookWhere = struct {
	ID                                    whereHelperint
	Title                                 whereHelperstring
	SubTitle                              whereHelpernull_String
	Slug                                  whereHelpernull_String
	Format                                whereHelperstring
	ContentType                           whereHelperstring
	Password                              whereHelpernull_String
	Password2                             whereHelpernull_String
	PublisherID                           whereHelpernull_Int
	PublishDate                           whereHelpernull_Time
	Language                              whereHelperstring
	AuthorID                              whereHelpernull_Int
	Author2ID                             whereHelpernull_Int
	Author3ID                             whereHelpernull_Int
	TranslatorID                          whereHelpernull_Int
	Translator2ID                         whereHelpernull_Int
	Translator3ID                         whereHelpernull_Int
	Isbn                                  whereHelpernull_String
	IsbnInt                               whereHelpernull_String
	Volume                                whereHelpernull_Int
	PaperPrice                            whereHelpernull_Float32
	ApplyPaperPrice                       whereHelperint8
	Price                                 whereHelperint
	MainPrice                             whereHelpernull_Int
	MultiplePrice                         whereHelperbool
	PriceTMP                              whereHelpernull_Int
	BasePrice                             whereHelperstring
	Price2                                whereHelpertypes_Decimal
	PackageDiscountPublisherParticipation whereHelpernull_Int
	Free                                  whereHelperint8
	UploadTime                            whereHelpertime_Time
	Filename                              whereHelpernull_String
	SampleFilename                        whereHelpernull_String
	ImageName                             whereHelpernull_String
	ImageSquare                           whereHelpernull_String
	OriginalTitle                         whereHelpernull_String
	OriginalPublisherID                   whereHelpernull_Int
	Description                           whereHelperstring
	Publish                               whereHelperint8
	PublishTime                           whereHelpernull_Time
	CheckTime                             whereHelpernull_Time
	Bugs                                  whereHelpernull_String
	CRC                                   whereHelpernull_Uint
	SampleCRC                             whereHelpernull_Uint
	Keywords                              whereHelpernull_String
	Su                                    whereHelpernull_Int8
	Sales                                 whereHelpernull_Int
	SalesTime                             whereHelpernull_Int
	SalesTMP                              whereHelpernull_Int
	SalesTimeTMP                          whereHelpernull_Int
	Rate                                  whereHelperfloat64
	RateCount                             whereHelperuint
	New                                   whereHelperbool
	Featured                              whereHelperbool
	LastGoodreadsCheck                    whereHelpernull_Time
	Filesize                              whereHelpernull_Int64
	SampleFilesize                        whereHelpernull_Int
	BKCRC                                 whereHelpernull_Uint
	BKSampleCRC                           whereHelpernull_Uint
	PageCount                             whereHelpernull_Int
	Provider                              whereHelperstring
	NarratorID                            whereHelpernull_Uint
	Narrator2ID                           whereHelpernull_Uint
	Narrator3ID                           whereHelpernull_Uint
	Duration                              whereHelpernull_Int
	OldCRC                                whereHelpernull_Int
	OldFilesize                           whereHelpernull_Int
	CRCDone                               whereHelperint8
	SuitableFor                           whereHelperstring
	FromAge                               whereHelpernull_Int8
	ToAge                                 whereHelpernull_Int8
	Flag                                  whereHelpernull_Int
	Encrypted                             whereHelperbool
	ImageCheck                            whereHelpernull_Int
	EncryptCheck                          whereHelpernull_Int
	SampleCheck                           whereHelpernull_Int
	SeoTitle                              whereHelpernull_String
	SeoDescription                        whereHelpernull_String
	TMPTitle                              whereHelpernull_String
	SeoProblem                            whereHelperbool
	Canonical                             whereHelpernull_String
	SeoFrontShow                          whereHelperbool
	Extradata                             whereHelpernull_String
	LastUpdate                            whereHelpernull_Time
}{
	ID:                                    whereHelperint{field: `id`},
	Title:                                 whereHelperstring{field: `title`},
	SubTitle:                              whereHelpernull_String{field: `sub_title`},
	Slug:                                  whereHelpernull_String{field: `slug`},
	Format:                                whereHelperstring{field: `format`},
	ContentType:                           whereHelperstring{field: `content_type`},
	Password:                              whereHelpernull_String{field: `password`},
	Password2:                             whereHelpernull_String{field: `password2`},
	PublisherID:                           whereHelpernull_Int{field: `publisher_id`},
	PublishDate:                           whereHelpernull_Time{field: `publish_date`},
	Language:                              whereHelperstring{field: `language`},
	AuthorID:                              whereHelpernull_Int{field: `author_id`},
	Author2ID:                             whereHelpernull_Int{field: `author2_id`},
	Author3ID:                             whereHelpernull_Int{field: `author3_id`},
	TranslatorID:                          whereHelpernull_Int{field: `translator_id`},
	Translator2ID:                         whereHelpernull_Int{field: `translator2_id`},
	Translator3ID:                         whereHelpernull_Int{field: `translator3_id`},
	Isbn:                                  whereHelpernull_String{field: `isbn`},
	IsbnInt:                               whereHelpernull_String{field: `isbn_int`},
	Volume:                                whereHelpernull_Int{field: `volume`},
	PaperPrice:                            whereHelpernull_Float32{field: `paper_price`},
	ApplyPaperPrice:                       whereHelperint8{field: `apply_paper_price`},
	Price:                                 whereHelperint{field: `price`},
	MainPrice:                             whereHelpernull_Int{field: `main_price`},
	MultiplePrice:                         whereHelperbool{field: `multiple_price`},
	PriceTMP:                              whereHelpernull_Int{field: `price_tmp`},
	BasePrice:                             whereHelperstring{field: `base_price`},
	Price2:                                whereHelpertypes_Decimal{field: `price2`},
	PackageDiscountPublisherParticipation: whereHelpernull_Int{field: `package_discount_publisher_participation`},
	Free:                                  whereHelperint8{field: `free`},
	UploadTime:                            whereHelpertime_Time{field: `upload_time`},
	Filename:                              whereHelpernull_String{field: `filename`},
	SampleFilename:                        whereHelpernull_String{field: `sample_filename`},
	ImageName:                             whereHelpernull_String{field: `image_name`},
	ImageSquare:                           whereHelpernull_String{field: `image_square`},
	OriginalTitle:                         whereHelpernull_String{field: `original_title`},
	OriginalPublisherID:                   whereHelpernull_Int{field: `original_publisher_id`},
	Description:                           whereHelperstring{field: `description`},
	Publish:                               whereHelperint8{field: `publish`},
	PublishTime:                           whereHelpernull_Time{field: `publish_time`},
	CheckTime:                             whereHelpernull_Time{field: `check_time`},
	Bugs:                                  whereHelpernull_String{field: `bugs`},
	CRC:                                   whereHelpernull_Uint{field: `crc`},
	SampleCRC:                             whereHelpernull_Uint{field: `sample_crc`},
	Keywords:                              whereHelpernull_String{field: `keywords`},
	Su:                                    whereHelpernull_Int8{field: `su`},
	Sales:                                 whereHelpernull_Int{field: `sales`},
	SalesTime:                             whereHelpernull_Int{field: `sales_time`},
	SalesTMP:                              whereHelpernull_Int{field: `sales_tmp`},
	SalesTimeTMP:                          whereHelpernull_Int{field: `sales_time_tmp`},
	Rate:                                  whereHelperfloat64{field: `rate`},
	RateCount:                             whereHelperuint{field: `rate_count`},
	New:                                   whereHelperbool{field: `new`},
	Featured:                              whereHelperbool{field: `featured`},
	LastGoodreadsCheck:                    whereHelpernull_Time{field: `last_goodreads_check`},
	Filesize:                              whereHelpernull_Int64{field: `filesize`},
	SampleFilesize:                        whereHelpernull_Int{field: `sample_filesize`},
	BKCRC:                                 whereHelpernull_Uint{field: `bk_crc`},
	BKSampleCRC:                           whereHelpernull_Uint{field: `bk_sample_crc`},
	PageCount:                             whereHelpernull_Int{field: `page_count`},
	Provider:                              whereHelperstring{field: `provider`},
	NarratorID:                            whereHelpernull_Uint{field: `narrator_id`},
	Narrator2ID:                           whereHelpernull_Uint{field: `narrator2_id`},
	Narrator3ID:                           whereHelpernull_Uint{field: `narrator3_id`},
	Duration:                              whereHelpernull_Int{field: `duration`},
	OldCRC:                                whereHelpernull_Int{field: `old_crc`},
	OldFilesize:                           whereHelpernull_Int{field: `old_filesize`},
	CRCDone:                               whereHelperint8{field: `crc_done`},
	SuitableFor:                           whereHelperstring{field: `suitable_for`},
	FromAge:                               whereHelpernull_Int8{field: `from_age`},
	ToAge:                                 whereHelpernull_Int8{field: `to_age`},
	Flag:                                  whereHelpernull_Int{field: `flag`},
	Encrypted:                             whereHelperbool{field: `encrypted`},
	ImageCheck:                            whereHelpernull_Int{field: `image_check`},
	EncryptCheck:                          whereHelpernull_Int{field: `encrypt_check`},
	SampleCheck:                           whereHelpernull_Int{field: `sample_check`},
	SeoTitle:                              whereHelpernull_String{field: `seo_title`},
	SeoDescription:                        whereHelpernull_String{field: `seo_description`},
	TMPTitle:                              whereHelpernull_String{field: `tmp_title`},
	SeoProblem:                            whereHelperbool{field: `seo_problem`},
	Canonical:                             whereHelpernull_String{field: `canonical`},
	SeoFrontShow:                          whereHelperbool{field: `seo_front_show`},
	Extradata:                             whereHelpernull_String{field: `extradata`},
	LastUpdate:                            whereHelpernull_Time{field: `last_update`},
}

// BookRels is where relationship names are stored.
var BookRels = struct {
	Author      string
	Translator  string
	Author2     string
	Author3     string
	Translator2 string
	Translator3 string
	BookStat    string
}{
	Author:      "Author",
	Translator:  "Translator",
	Author2:     "Author2",
	Author3:     "Author3",
	Translator2: "Translator2",
	Translator3: "Translator3",
	BookStat:    "BookStat",
}

// bookR is where relationships are stored.
type bookR struct {
	Author      *Author
	Translator  *Author
	Author2     *Author
	Author3     *Author
	Translator2 *Author
	Translator3 *Author
	BookStat    *BookStat
}

// NewStruct creates a new relationship struct
func (*bookR) NewStruct() *bookR {
	return &bookR{}
}

// bookL is where Load methods for each relationship are stored.
type bookL struct{}

var (
	bookColumns               = []string{"id", "title", "sub_title", "slug", "format", "content_type", "password", "password2", "publisher_id", "publish_date", "language", "author_id", "author2_id", "author3_id", "translator_id", "translator2_id", "translator3_id", "isbn", "isbn_int", "volume", "paper_price", "apply_paper_price", "price", "main_price", "multiple_price", "price_tmp", "base_price", "price2", "package_discount_publisher_participation", "free", "upload_time", "filename", "sample_filename", "image_name", "image_square", "original_title", "original_publisher_id", "description", "publish", "publish_time", "check_time", "bugs", "crc", "sample_crc", "keywords", "su", "sales", "sales_time", "sales_tmp", "sales_time_tmp", "rate", "rate_count", "new", "featured", "last_goodreads_check", "filesize", "sample_filesize", "bk_crc", "bk_sample_crc", "page_count", "provider", "narrator_id", "narrator2_id", "narrator3_id", "duration", "old_crc", "old_filesize", "crc_done", "suitable_for", "from_age", "to_age", "flag", "encrypted", "image_check", "encrypt_check", "sample_check", "seo_title", "seo_description", "tmp_title", "seo_problem", "canonical", "seo_front_show", "extradata", "last_update"}
	bookColumnsWithoutDefault = []string{"title", "sub_title", "slug", "format", "password", "password2", "publisher_id", "publish_date", "language", "author_id", "author2_id", "author3_id", "translator_id", "translator2_id", "translator3_id", "isbn", "isbn_int", "volume", "paper_price", "apply_paper_price", "price", "main_price", "price_tmp", "price2", "package_discount_publisher_participation", "free", "upload_time", "filename", "sample_filename", "image_name", "image_square", "original_title", "original_publisher_id", "description", "publish", "publish_time", "check_time", "bugs", "crc", "sample_crc", "keywords", "su", "sales_tmp", "sales_time_tmp", "last_goodreads_check", "filesize", "sample_filesize", "bk_crc", "bk_sample_crc", "page_count", "narrator_id", "narrator2_id", "narrator3_id", "duration", "old_crc", "old_filesize", "from_age", "to_age", "flag", "image_check", "encrypt_check", "sample_check", "seo_title", "seo_description", "tmp_title", "canonical", "seo_front_show", "extradata"}
	bookColumnsWithDefault    = []string{"id", "content_type", "multiple_price", "base_price", "sales", "sales_time", "rate", "rate_count", "new", "featured", "provider", "crc_done", "suitable_for", "encrypted", "seo_problem", "last_update"}
	bookPrimaryKeyColumns     = []string{"id"}
)

type (
	// BookSlice is an alias for a slice of pointers to Book.
	// This should generally be used opposed to []Book.
	BookSlice []*Book
	// BookHook is the signature for custom Book hook methods
	BookHook func(context.Context, boil.ContextExecutor, *Book) error

	bookQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	bookType                 = reflect.TypeOf(&Book{})
	bookMapping              = queries.MakeStructMapping(bookType)
	bookPrimaryKeyMapping, _ = queries.BindMapping(bookType, bookMapping, bookPrimaryKeyColumns)
	bookInsertCacheMut       sync.RWMutex
	bookInsertCache          = make(map[string]insertCache)
	bookUpdateCacheMut       sync.RWMutex
	bookUpdateCache          = make(map[string]updateCache)
	bookUpsertCacheMut       sync.RWMutex
	bookUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var bookBeforeInsertHooks []BookHook
var bookBeforeUpdateHooks []BookHook
var bookBeforeDeleteHooks []BookHook
var bookBeforeUpsertHooks []BookHook

var bookAfterInsertHooks []BookHook
var bookAfterSelectHooks []BookHook
var bookAfterUpdateHooks []BookHook
var bookAfterDeleteHooks []BookHook
var bookAfterUpsertHooks []BookHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Book) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bookBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Book) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bookBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Book) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bookBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Book) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bookBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Book) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bookAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Book) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bookAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Book) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bookAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Book) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bookAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Book) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range bookAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddBookHook registers your hook function for all future operations.
func AddBookHook(hookPoint boil.HookPoint, bookHook BookHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		bookBeforeInsertHooks = append(bookBeforeInsertHooks, bookHook)
	case boil.BeforeUpdateHook:
		bookBeforeUpdateHooks = append(bookBeforeUpdateHooks, bookHook)
	case boil.BeforeDeleteHook:
		bookBeforeDeleteHooks = append(bookBeforeDeleteHooks, bookHook)
	case boil.BeforeUpsertHook:
		bookBeforeUpsertHooks = append(bookBeforeUpsertHooks, bookHook)
	case boil.AfterInsertHook:
		bookAfterInsertHooks = append(bookAfterInsertHooks, bookHook)
	case boil.AfterSelectHook:
		bookAfterSelectHooks = append(bookAfterSelectHooks, bookHook)
	case boil.AfterUpdateHook:
		bookAfterUpdateHooks = append(bookAfterUpdateHooks, bookHook)
	case boil.AfterDeleteHook:
		bookAfterDeleteHooks = append(bookAfterDeleteHooks, bookHook)
	case boil.AfterUpsertHook:
		bookAfterUpsertHooks = append(bookAfterUpsertHooks, bookHook)
	}
}

// OneG returns a single book record from the query using the global executor.
func (q bookQuery) OneG(ctx context.Context) (*Book, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single book record from the query.
func (q bookQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Book, error) {
	o := &Book{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for book")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Book records from the query using the global executor.
func (q bookQuery) AllG(ctx context.Context) (BookSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all Book records from the query.
func (q bookQuery) All(ctx context.Context, exec boil.ContextExecutor) (BookSlice, error) {
	var o []*Book

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Book slice")
	}

	if len(bookAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Book records in the query, and panics on error.
func (q bookQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all Book records in the query.
func (q bookQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count book rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table, and panics on error.
func (q bookQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q bookQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if book exists")
	}

	return count > 0, nil
}

// Author pointed to by the foreign key.
func (o *Book) Author(mods ...qm.QueryMod) authorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.AuthorID),
	}

	queryMods = append(queryMods, mods...)

	query := Authors(queryMods...)
	queries.SetFrom(query.Query, "`author`")

	return query
}

// Translator pointed to by the foreign key.
func (o *Book) Translator(mods ...qm.QueryMod) authorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.TranslatorID),
	}

	queryMods = append(queryMods, mods...)

	query := Authors(queryMods...)
	queries.SetFrom(query.Query, "`author`")

	return query
}

// Author2 pointed to by the foreign key.
func (o *Book) Author2(mods ...qm.QueryMod) authorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.Author2ID),
	}

	queryMods = append(queryMods, mods...)

	query := Authors(queryMods...)
	queries.SetFrom(query.Query, "`author`")

	return query
}

// Author3 pointed to by the foreign key.
func (o *Book) Author3(mods ...qm.QueryMod) authorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.Author3ID),
	}

	queryMods = append(queryMods, mods...)

	query := Authors(queryMods...)
	queries.SetFrom(query.Query, "`author`")

	return query
}

// Translator2 pointed to by the foreign key.
func (o *Book) Translator2(mods ...qm.QueryMod) authorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.Translator2ID),
	}

	queryMods = append(queryMods, mods...)

	query := Authors(queryMods...)
	queries.SetFrom(query.Query, "`author`")

	return query
}

// Translator3 pointed to by the foreign key.
func (o *Book) Translator3(mods ...qm.QueryMod) authorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.Translator3ID),
	}

	queryMods = append(queryMods, mods...)

	query := Authors(queryMods...)
	queries.SetFrom(query.Query, "`author`")

	return query
}

// BookStat pointed to by the foreign key.
func (o *Book) BookStat(mods ...qm.QueryMod) bookStatQuery {
	queryMods := []qm.QueryMod{
		qm.Where("book_id=?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := BookStats(queryMods...)
	queries.SetFrom(query.Query, "`book_stats`")

	return query
}

// LoadAuthor allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (bookL) LoadAuthor(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBook interface{}, mods queries.Applicator) error {
	var slice []*Book
	var object *Book

	if singular {
		object = maybeBook.(*Book)
	} else {
		slice = *maybeBook.(*[]*Book)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bookR{}
		}
		if !queries.IsNil(object.AuthorID) {
			args = append(args, object.AuthorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bookR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AuthorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AuthorID) {
				args = append(args, obj.AuthorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`author`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Author")
	}

	var resultSlice []*Author
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Author")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for author")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for author")
	}

	if len(bookAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Author = foreign
		if foreign.R == nil {
			foreign.R = &authorR{}
		}
		foreign.R.Books = append(foreign.R.Books, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AuthorID, foreign.ID) {
				local.R.Author = foreign
				if foreign.R == nil {
					foreign.R = &authorR{}
				}
				foreign.R.Books = append(foreign.R.Books, local)
				break
			}
		}
	}

	return nil
}

// LoadTranslator allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (bookL) LoadTranslator(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBook interface{}, mods queries.Applicator) error {
	var slice []*Book
	var object *Book

	if singular {
		object = maybeBook.(*Book)
	} else {
		slice = *maybeBook.(*[]*Book)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bookR{}
		}
		if !queries.IsNil(object.TranslatorID) {
			args = append(args, object.TranslatorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bookR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.TranslatorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.TranslatorID) {
				args = append(args, obj.TranslatorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`author`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Author")
	}

	var resultSlice []*Author
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Author")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for author")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for author")
	}

	if len(bookAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Translator = foreign
		if foreign.R == nil {
			foreign.R = &authorR{}
		}
		foreign.R.TranslatorBooks = append(foreign.R.TranslatorBooks, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TranslatorID, foreign.ID) {
				local.R.Translator = foreign
				if foreign.R == nil {
					foreign.R = &authorR{}
				}
				foreign.R.TranslatorBooks = append(foreign.R.TranslatorBooks, local)
				break
			}
		}
	}

	return nil
}

// LoadAuthor2 allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (bookL) LoadAuthor2(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBook interface{}, mods queries.Applicator) error {
	var slice []*Book
	var object *Book

	if singular {
		object = maybeBook.(*Book)
	} else {
		slice = *maybeBook.(*[]*Book)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bookR{}
		}
		if !queries.IsNil(object.Author2ID) {
			args = append(args, object.Author2ID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bookR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Author2ID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Author2ID) {
				args = append(args, obj.Author2ID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`author`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Author")
	}

	var resultSlice []*Author
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Author")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for author")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for author")
	}

	if len(bookAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Author2 = foreign
		if foreign.R == nil {
			foreign.R = &authorR{}
		}
		foreign.R.Author2Books = append(foreign.R.Author2Books, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Author2ID, foreign.ID) {
				local.R.Author2 = foreign
				if foreign.R == nil {
					foreign.R = &authorR{}
				}
				foreign.R.Author2Books = append(foreign.R.Author2Books, local)
				break
			}
		}
	}

	return nil
}

// LoadAuthor3 allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (bookL) LoadAuthor3(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBook interface{}, mods queries.Applicator) error {
	var slice []*Book
	var object *Book

	if singular {
		object = maybeBook.(*Book)
	} else {
		slice = *maybeBook.(*[]*Book)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bookR{}
		}
		if !queries.IsNil(object.Author3ID) {
			args = append(args, object.Author3ID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bookR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Author3ID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Author3ID) {
				args = append(args, obj.Author3ID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`author`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Author")
	}

	var resultSlice []*Author
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Author")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for author")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for author")
	}

	if len(bookAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Author3 = foreign
		if foreign.R == nil {
			foreign.R = &authorR{}
		}
		foreign.R.Author3Books = append(foreign.R.Author3Books, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Author3ID, foreign.ID) {
				local.R.Author3 = foreign
				if foreign.R == nil {
					foreign.R = &authorR{}
				}
				foreign.R.Author3Books = append(foreign.R.Author3Books, local)
				break
			}
		}
	}

	return nil
}

// LoadTranslator2 allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (bookL) LoadTranslator2(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBook interface{}, mods queries.Applicator) error {
	var slice []*Book
	var object *Book

	if singular {
		object = maybeBook.(*Book)
	} else {
		slice = *maybeBook.(*[]*Book)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bookR{}
		}
		if !queries.IsNil(object.Translator2ID) {
			args = append(args, object.Translator2ID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bookR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Translator2ID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Translator2ID) {
				args = append(args, obj.Translator2ID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`author`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Author")
	}

	var resultSlice []*Author
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Author")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for author")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for author")
	}

	if len(bookAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Translator2 = foreign
		if foreign.R == nil {
			foreign.R = &authorR{}
		}
		foreign.R.Translator2Books = append(foreign.R.Translator2Books, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Translator2ID, foreign.ID) {
				local.R.Translator2 = foreign
				if foreign.R == nil {
					foreign.R = &authorR{}
				}
				foreign.R.Translator2Books = append(foreign.R.Translator2Books, local)
				break
			}
		}
	}

	return nil
}

// LoadTranslator3 allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (bookL) LoadTranslator3(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBook interface{}, mods queries.Applicator) error {
	var slice []*Book
	var object *Book

	if singular {
		object = maybeBook.(*Book)
	} else {
		slice = *maybeBook.(*[]*Book)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bookR{}
		}
		if !queries.IsNil(object.Translator3ID) {
			args = append(args, object.Translator3ID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bookR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Translator3ID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Translator3ID) {
				args = append(args, obj.Translator3ID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`author`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Author")
	}

	var resultSlice []*Author
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Author")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for author")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for author")
	}

	if len(bookAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Translator3 = foreign
		if foreign.R == nil {
			foreign.R = &authorR{}
		}
		foreign.R.Translator3Books = append(foreign.R.Translator3Books, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Translator3ID, foreign.ID) {
				local.R.Translator3 = foreign
				if foreign.R == nil {
					foreign.R = &authorR{}
				}
				foreign.R.Translator3Books = append(foreign.R.Translator3Books, local)
				break
			}
		}
	}

	return nil
}

// LoadBookStat allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (bookL) LoadBookStat(ctx context.Context, e boil.ContextExecutor, singular bool, maybeBook interface{}, mods queries.Applicator) error {
	var slice []*Book
	var object *Book

	if singular {
		object = maybeBook.(*Book)
	} else {
		slice = *maybeBook.(*[]*Book)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &bookR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &bookR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`book_stats`), qm.WhereIn(`book_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BookStat")
	}

	var resultSlice []*BookStat
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BookStat")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for book_stats")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for book_stats")
	}

	if len(bookAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BookStat = foreign
		if foreign.R == nil {
			foreign.R = &bookStatR{}
		}
		foreign.R.Book = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.BookID {
				local.R.BookStat = foreign
				if foreign.R == nil {
					foreign.R = &bookStatR{}
				}
				foreign.R.Book = local
				break
			}
		}
	}

	return nil
}

// SetAuthorG of the book to the related item.
// Sets o.R.Author to related.
// Adds o to related.R.Books.
// Uses the global database handle.
func (o *Book) SetAuthorG(ctx context.Context, insert bool, related *Author) error {
	return o.SetAuthor(ctx, boil.GetContextDB(), insert, related)
}

// SetAuthor of the book to the related item.
// Sets o.R.Author to related.
// Adds o to related.R.Books.
func (o *Book) SetAuthor(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Author) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `book` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"author_id"}),
		strmangle.WhereClause("`", "`", 0, bookPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AuthorID, related.ID)
	if o.R == nil {
		o.R = &bookR{
			Author: related,
		}
	} else {
		o.R.Author = related
	}

	if related.R == nil {
		related.R = &authorR{
			Books: BookSlice{o},
		}
	} else {
		related.R.Books = append(related.R.Books, o)
	}

	return nil
}

// RemoveAuthorG relationship.
// Sets o.R.Author to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Book) RemoveAuthorG(ctx context.Context, related *Author) error {
	return o.RemoveAuthor(ctx, boil.GetContextDB(), related)
}

// RemoveAuthor relationship.
// Sets o.R.Author to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Book) RemoveAuthor(ctx context.Context, exec boil.ContextExecutor, related *Author) error {
	var err error

	queries.SetScanner(&o.AuthorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("author_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Author = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Books {
		if queries.Equal(o.AuthorID, ri.AuthorID) {
			continue
		}

		ln := len(related.R.Books)
		if ln > 1 && i < ln-1 {
			related.R.Books[i] = related.R.Books[ln-1]
		}
		related.R.Books = related.R.Books[:ln-1]
		break
	}
	return nil
}

// SetTranslatorG of the book to the related item.
// Sets o.R.Translator to related.
// Adds o to related.R.TranslatorBooks.
// Uses the global database handle.
func (o *Book) SetTranslatorG(ctx context.Context, insert bool, related *Author) error {
	return o.SetTranslator(ctx, boil.GetContextDB(), insert, related)
}

// SetTranslator of the book to the related item.
// Sets o.R.Translator to related.
// Adds o to related.R.TranslatorBooks.
func (o *Book) SetTranslator(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Author) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `book` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"translator_id"}),
		strmangle.WhereClause("`", "`", 0, bookPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.TranslatorID, related.ID)
	if o.R == nil {
		o.R = &bookR{
			Translator: related,
		}
	} else {
		o.R.Translator = related
	}

	if related.R == nil {
		related.R = &authorR{
			TranslatorBooks: BookSlice{o},
		}
	} else {
		related.R.TranslatorBooks = append(related.R.TranslatorBooks, o)
	}

	return nil
}

// RemoveTranslatorG relationship.
// Sets o.R.Translator to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Book) RemoveTranslatorG(ctx context.Context, related *Author) error {
	return o.RemoveTranslator(ctx, boil.GetContextDB(), related)
}

// RemoveTranslator relationship.
// Sets o.R.Translator to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Book) RemoveTranslator(ctx context.Context, exec boil.ContextExecutor, related *Author) error {
	var err error

	queries.SetScanner(&o.TranslatorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("translator_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Translator = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.TranslatorBooks {
		if queries.Equal(o.TranslatorID, ri.TranslatorID) {
			continue
		}

		ln := len(related.R.TranslatorBooks)
		if ln > 1 && i < ln-1 {
			related.R.TranslatorBooks[i] = related.R.TranslatorBooks[ln-1]
		}
		related.R.TranslatorBooks = related.R.TranslatorBooks[:ln-1]
		break
	}
	return nil
}

// SetAuthor2G of the book to the related item.
// Sets o.R.Author2 to related.
// Adds o to related.R.Author2Books.
// Uses the global database handle.
func (o *Book) SetAuthor2G(ctx context.Context, insert bool, related *Author) error {
	return o.SetAuthor2(ctx, boil.GetContextDB(), insert, related)
}

// SetAuthor2 of the book to the related item.
// Sets o.R.Author2 to related.
// Adds o to related.R.Author2Books.
func (o *Book) SetAuthor2(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Author) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `book` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"author2_id"}),
		strmangle.WhereClause("`", "`", 0, bookPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Author2ID, related.ID)
	if o.R == nil {
		o.R = &bookR{
			Author2: related,
		}
	} else {
		o.R.Author2 = related
	}

	if related.R == nil {
		related.R = &authorR{
			Author2Books: BookSlice{o},
		}
	} else {
		related.R.Author2Books = append(related.R.Author2Books, o)
	}

	return nil
}

// RemoveAuthor2G relationship.
// Sets o.R.Author2 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Book) RemoveAuthor2G(ctx context.Context, related *Author) error {
	return o.RemoveAuthor2(ctx, boil.GetContextDB(), related)
}

// RemoveAuthor2 relationship.
// Sets o.R.Author2 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Book) RemoveAuthor2(ctx context.Context, exec boil.ContextExecutor, related *Author) error {
	var err error

	queries.SetScanner(&o.Author2ID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("author2_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Author2 = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Author2Books {
		if queries.Equal(o.Author2ID, ri.Author2ID) {
			continue
		}

		ln := len(related.R.Author2Books)
		if ln > 1 && i < ln-1 {
			related.R.Author2Books[i] = related.R.Author2Books[ln-1]
		}
		related.R.Author2Books = related.R.Author2Books[:ln-1]
		break
	}
	return nil
}

// SetAuthor3G of the book to the related item.
// Sets o.R.Author3 to related.
// Adds o to related.R.Author3Books.
// Uses the global database handle.
func (o *Book) SetAuthor3G(ctx context.Context, insert bool, related *Author) error {
	return o.SetAuthor3(ctx, boil.GetContextDB(), insert, related)
}

// SetAuthor3 of the book to the related item.
// Sets o.R.Author3 to related.
// Adds o to related.R.Author3Books.
func (o *Book) SetAuthor3(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Author) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `book` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"author3_id"}),
		strmangle.WhereClause("`", "`", 0, bookPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Author3ID, related.ID)
	if o.R == nil {
		o.R = &bookR{
			Author3: related,
		}
	} else {
		o.R.Author3 = related
	}

	if related.R == nil {
		related.R = &authorR{
			Author3Books: BookSlice{o},
		}
	} else {
		related.R.Author3Books = append(related.R.Author3Books, o)
	}

	return nil
}

// RemoveAuthor3G relationship.
// Sets o.R.Author3 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Book) RemoveAuthor3G(ctx context.Context, related *Author) error {
	return o.RemoveAuthor3(ctx, boil.GetContextDB(), related)
}

// RemoveAuthor3 relationship.
// Sets o.R.Author3 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Book) RemoveAuthor3(ctx context.Context, exec boil.ContextExecutor, related *Author) error {
	var err error

	queries.SetScanner(&o.Author3ID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("author3_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Author3 = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Author3Books {
		if queries.Equal(o.Author3ID, ri.Author3ID) {
			continue
		}

		ln := len(related.R.Author3Books)
		if ln > 1 && i < ln-1 {
			related.R.Author3Books[i] = related.R.Author3Books[ln-1]
		}
		related.R.Author3Books = related.R.Author3Books[:ln-1]
		break
	}
	return nil
}

// SetTranslator2G of the book to the related item.
// Sets o.R.Translator2 to related.
// Adds o to related.R.Translator2Books.
// Uses the global database handle.
func (o *Book) SetTranslator2G(ctx context.Context, insert bool, related *Author) error {
	return o.SetTranslator2(ctx, boil.GetContextDB(), insert, related)
}

// SetTranslator2 of the book to the related item.
// Sets o.R.Translator2 to related.
// Adds o to related.R.Translator2Books.
func (o *Book) SetTranslator2(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Author) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `book` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"translator2_id"}),
		strmangle.WhereClause("`", "`", 0, bookPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Translator2ID, related.ID)
	if o.R == nil {
		o.R = &bookR{
			Translator2: related,
		}
	} else {
		o.R.Translator2 = related
	}

	if related.R == nil {
		related.R = &authorR{
			Translator2Books: BookSlice{o},
		}
	} else {
		related.R.Translator2Books = append(related.R.Translator2Books, o)
	}

	return nil
}

// RemoveTranslator2G relationship.
// Sets o.R.Translator2 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Book) RemoveTranslator2G(ctx context.Context, related *Author) error {
	return o.RemoveTranslator2(ctx, boil.GetContextDB(), related)
}

// RemoveTranslator2 relationship.
// Sets o.R.Translator2 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Book) RemoveTranslator2(ctx context.Context, exec boil.ContextExecutor, related *Author) error {
	var err error

	queries.SetScanner(&o.Translator2ID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("translator2_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Translator2 = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Translator2Books {
		if queries.Equal(o.Translator2ID, ri.Translator2ID) {
			continue
		}

		ln := len(related.R.Translator2Books)
		if ln > 1 && i < ln-1 {
			related.R.Translator2Books[i] = related.R.Translator2Books[ln-1]
		}
		related.R.Translator2Books = related.R.Translator2Books[:ln-1]
		break
	}
	return nil
}

// SetTranslator3G of the book to the related item.
// Sets o.R.Translator3 to related.
// Adds o to related.R.Translator3Books.
// Uses the global database handle.
func (o *Book) SetTranslator3G(ctx context.Context, insert bool, related *Author) error {
	return o.SetTranslator3(ctx, boil.GetContextDB(), insert, related)
}

// SetTranslator3 of the book to the related item.
// Sets o.R.Translator3 to related.
// Adds o to related.R.Translator3Books.
func (o *Book) SetTranslator3(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Author) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `book` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"translator3_id"}),
		strmangle.WhereClause("`", "`", 0, bookPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Translator3ID, related.ID)
	if o.R == nil {
		o.R = &bookR{
			Translator3: related,
		}
	} else {
		o.R.Translator3 = related
	}

	if related.R == nil {
		related.R = &authorR{
			Translator3Books: BookSlice{o},
		}
	} else {
		related.R.Translator3Books = append(related.R.Translator3Books, o)
	}

	return nil
}

// RemoveTranslator3G relationship.
// Sets o.R.Translator3 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *Book) RemoveTranslator3G(ctx context.Context, related *Author) error {
	return o.RemoveTranslator3(ctx, boil.GetContextDB(), related)
}

// RemoveTranslator3 relationship.
// Sets o.R.Translator3 to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Book) RemoveTranslator3(ctx context.Context, exec boil.ContextExecutor, related *Author) error {
	var err error

	queries.SetScanner(&o.Translator3ID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("translator3_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Translator3 = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Translator3Books {
		if queries.Equal(o.Translator3ID, ri.Translator3ID) {
			continue
		}

		ln := len(related.R.Translator3Books)
		if ln > 1 && i < ln-1 {
			related.R.Translator3Books[i] = related.R.Translator3Books[ln-1]
		}
		related.R.Translator3Books = related.R.Translator3Books[:ln-1]
		break
	}
	return nil
}

// SetBookStatG of the book to the related item.
// Sets o.R.BookStat to related.
// Adds o to related.R.Book.
// Uses the global database handle.
func (o *Book) SetBookStatG(ctx context.Context, insert bool, related *BookStat) error {
	return o.SetBookStat(ctx, boil.GetContextDB(), insert, related)
}

// SetBookStat of the book to the related item.
// Sets o.R.BookStat to related.
// Adds o to related.R.Book.
func (o *Book) SetBookStat(ctx context.Context, exec boil.ContextExecutor, insert bool, related *BookStat) error {
	var err error

	if insert {
		related.BookID = o.ID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE `book_stats` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, []string{"book_id"}),
			strmangle.WhereClause("`", "`", 0, bookStatPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.BookID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}

		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.BookID = o.ID

	}

	if o.R == nil {
		o.R = &bookR{
			BookStat: related,
		}
	} else {
		o.R.BookStat = related
	}

	if related.R == nil {
		related.R = &bookStatR{
			Book: o,
		}
	} else {
		related.R.Book = o
	}
	return nil
}

// Books retrieves all the records using an executor.
func Books(mods ...qm.QueryMod) bookQuery {
	mods = append(mods, qm.From("`book`"))
	return bookQuery{NewQuery(mods...)}
}

// FindBookG retrieves a single record by ID.
func FindBookG(ctx context.Context, iD int, selectCols ...string) (*Book, error) {
	return FindBook(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindBook retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindBook(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Book, error) {
	bookObj := &Book{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `book` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, bookObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from book")
	}

	return bookObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Book) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Book) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no book provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(bookColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	bookInsertCacheMut.RLock()
	cache, cached := bookInsertCache[key]
	bookInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			bookColumns,
			bookColumnsWithDefault,
			bookColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(bookType, bookMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(bookType, bookMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `book` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `book` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `book` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, bookPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into book")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == bookMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for book")
	}

CacheNoHooks:
	if !cached {
		bookInsertCacheMut.Lock()
		bookInsertCache[key] = cache
		bookInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Book record using the global executor.
// See Update for more documentation.
func (o *Book) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the Book.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Book) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	bookUpdateCacheMut.RLock()
	cache, cached := bookUpdateCache[key]
	bookUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			bookColumns,
			bookPrimaryKeyColumns,
		)

		if len(wl) == 0 {
			return 0, errors.New("models: unable to update book, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `book` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, bookPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(bookType, bookMapping, append(wl, bookPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update book row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for book")
	}

	if !cached {
		bookUpdateCacheMut.Lock()
		bookUpdateCache[key] = cache
		bookUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q bookQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q bookQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for book")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for book")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o BookSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o BookSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), bookPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `book` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, bookPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in book slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all book")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Book) UpsertG(ctx context.Context, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateColumns, insertColumns)
}

var mySQLBookUniqueColumns = []string{
	"id",
	"slug",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Book) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no book provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(bookColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLBookUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	bookUpsertCacheMut.RLock()
	cache, cached := bookUpsertCache[key]
	bookUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			bookColumns,
			bookColumnsWithDefault,
			bookColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			bookColumns,
			bookPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert book, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "book", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `book` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(bookType, bookMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(bookType, bookMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for book")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == bookMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(bookType, bookMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for book")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for book")
	}

CacheNoHooks:
	if !cached {
		bookUpsertCacheMut.Lock()
		bookUpsertCache[key] = cache
		bookUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Book record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Book) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single Book record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Book) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Book provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), bookPrimaryKeyMapping)
	sql := "DELETE FROM `book` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from book")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for book")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q bookQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no bookQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from book")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for book")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o BookSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o BookSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Book slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(bookBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), bookPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `book` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, bookPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from book slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for book")
	}

	if len(bookAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Book) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: no Book provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Book) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindBook(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *BookSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: empty BookSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *BookSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := BookSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), bookPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `book`.* FROM `book` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, bookPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in BookSlice")
	}

	*o = slice

	return nil
}

// BookExistsG checks if the Book row exists.
func BookExistsG(ctx context.Context, iD int) (bool, error) {
	return BookExists(ctx, boil.GetContextDB(), iD)
}

// BookExists checks if the Book row exists.
func BookExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `book` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if book exists")
	}

	return exists, nil
}
